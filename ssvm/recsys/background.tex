% !TEX root=main.tex

We now formalise the problem of interest.

%
\subsection{Trajectory recommendation}

Fix some set $\PCal$ of points-of-interest (POIs) in a city.
A \emph{trajectory}\footnote{In graph theory, this is also referred to as a walk.} is any sequence of POIs, possibly containing loops (repeated POIs).
In the \emph{trajectory recommendation} problem, we are given as input a training set of trajectories visited by travellers in the city.
From this, we wish to design a \emph{trajectory recommender}, which accepts a
\emph{trajectory query} $\mathbf{x} = (s, l)$, comprising a start POI $s \in \PCal$, and trip length $l \!>\! 1$ (\ie the desired number of POIs, including $s$),
and produces one or more sequences of POIs that conform to the query.

Formally, let $\XCal \defEq \PCal \times \{ 2, 3, \ldots \}$ be the set of possible queries,
$\YCal \defEq \bigcup_{l = 2}^\infty \PCal^l$ be the set of all possible trajectories,
and for fixed $\x \in \XCal$, $\YCal_{\x} \subset \YCal$ be the set of trajectories that conform to the constraints imposed by $\mathbf{x}$.
Then, the {trajectory recommendation} problem has:

\vspace{0.5\baselineskip}

\begin{mdframed}[innertopmargin=3pt,innerbottommargin=3pt,skipbelow=5pt,roundcorner=8pt,backgroundcolor=red!3,topline=false,rightline=false,leftline=false,bottomline=false]
{\sc Input}: training set $\left\{ \left( \x^{(i)}, \y^{(i)} \right) \right\}_{i = 1}^n \in ( \XCal \times \YCal )^n$ \\
{\sc Output}: a trajectory recommender $r \colon \XCal \to \YCal$ 
\end{mdframed}

\vspace{0.5\baselineskip}

One way to design a trajectory recommender is to find a scoring function $f \colon \XCal \times \YCal \to \mathbb{R}$, and let
\begin{equation}
	\label{eqn:argmax}
	r( x ) \defEq \argmax_{\mathbf{y} \in \YCal_x}~f(\mathbf{x}, \mathbf{y}).
\end{equation}
%In particular, $\mathbf{y} = (s,~ y_2, \dots, y_l)$ is a trajectory with $l$ POIs. %, which has no sub-tours. %i.e. $y_j \ne y_k$ if $j \ne k$.
%This was the view proposed in~\cite{cikm16paper} where they authors considered an
%objective function that added two components together: a POI score and a transition score.
Several choices of $f$ are possible.
\citet{cikm16paper} proposed to use the output of a RankSVM model, combined with a transition score between POIs.
While offering strong performance, this method has a conceptual disadvantage highlighted in the previous section:
it does not model global cohesion, and thus can lead to solutions such as recommending three restaurants in a row.
To overcome this, \citet{Chen:2017} proposed a structured SVM solution.
In the case of a structured SVM with pairwise potentials, the optimisation in Equation \ref{eqn:argmax} can be solved with the classic Viterbi algorithm.


%
\subsection{Path recommendation}

We argue that the above problem definition is incomplete for a simple reason:
in most cases, a tourist will not want to revisit the same POI.
That is, we argue that what is needed is to recommend a \emph{path}, \ie a trajectory that does not have any repeated POIs.
Let $\thickbar{\YCal} \subset \YCal$ be the set of all possible paths,
and for fixed $\x \in \XCal$, let $\thickbar{\YCal}_{\x} \subset \thickbar{\YCal}$ be the set of paths that conform to the constraints imposed by $\mathbf{x}$.
We now wish to construct a path recommender $r \colon \XCal \to \thickbar{\YCal}$ via
\begin{equation}
	\label{eqn:argmax-path}
	r( x ) \defEq \argmax_{\mathbf{y} \in \thickbar{\YCal}_x}~f(\mathbf{x}, \mathbf{y}).
\end{equation}

Equation \ref{eqn:argmax-path} takes us beyond the realm of the standard Viterbi algorithm, as the top-scoring sequence in Equation \ref{eqn:argmax} may well have a loop.
There are now two distinct modes of attack available:
\begin{enumerate}
	\item seek an approximate solution to the problem,
	via heuristics that remove loops present in the standard Viterbi solution,
	or by greedily constructing a loop-free solution.

	\item seek an exact solution to the problem,
	via top-$K$ extensions of the Viterbi algorithm (known as list Viterbi algorithms),
	or integer linear programming formulations.
\end{enumerate}
We now detail these possible approaches in more detail.
Figure \ref{fig:schematics} gives a schematic overview of these algorithms.

\tikzstyle{state}=[shape=circle,draw=blue!50,fill=blue!20]
\tikzstyle{state2}=[shape=circle,draw=purple!50,fill=purple!20]
\tikzstyle{hiddenState}=[shape=circle,draw=gray!50,fill=gray!20,dashed]
\tikzstyle{specialState}=[shape=circle,double=red,draw=blue!50,fill=blue!20,dashed]
\tikzstyle{observation}=[shape=rectangle,draw=orange!50,fill=orange!20]
\tikzstyle{hiddenObservation}=[shape=rectangle,draw=gray!50,fill=gray!20,dashed]
\tikzstyle{lightedge}=[<-,thin]
\tikzstyle{mainstate}=[state,ultra thick]
\tikzstyle{mainedge}=[<-,ultra thick]

\begin{figure*}[!h]
    \centering
    %\subfloat[Original prediction with loop (dashed).]{
    \subfloat[{\sc Greedy} (\S\ref{sec:greedy}).]{
    \begin{tikzpicture}[baseline=(s1.base)]
        % first-best
        \node[specialState] (s1) at (0,0)  {$1$};

        %\node[hiddenState] (s2) at (1,1.5)  {$2$};
        \node[hiddenState]  (s3) at (1,1)  {$3$};
        \node[specialState] (s4) at (1,0)    {$2$};
        \node[hiddenState]  (s5) at (1,-1) {$4$};
        %\node[hiddenState] (s6) at (1,-1.5)  {$6$};

        \node[draw=none] (s40) at (2,1)  {};
        \node[draw=none] (s41) at (2,0)     {};
        \node[draw=none] (s42) at (2,-1) {};

        \node[draw=none] (s411) at (2.25,0)     {$\ldots$};

        %\draw [->,ultra thin] (s1) to (s2);
        \draw [->,ultra thin] (s1) to (s3);
        \draw [->,ultra thick] (s1) to (s4);
        \draw [->,ultra thin] (s1) to (s5);
        %\draw [->,ultra thin] (s1) to (s6);

        \draw [->,ultra thin] (s4) to (s40);
        \draw [->,ultra thin] (s4) to (s41) node [draw=none] at (1.625,0) {$/$};
        \draw [->,ultra thin] (s4) to (s42);
    \end{tikzpicture}
    }%   
    \qquad    
    %\resizebox{0.2\textwidth}{!}{
    \subfloat[{\sc LoopElim} (\S\ref{sec:loop-elim}).]{
    \begin{tikzpicture}[baseline=(s0.base)]
        % states
        \node[state] (s0) at (0,0) {$1$};
        \node[state] (s1) at (1,0) {$2$}
            edge [<-,ultra thick] (s0);
        \node[state] (s2) at (2,0) {$3$}
            edge [<-,ultra thick] (s1);
        \node[state] (s3) at (3,0) {$4$}
            edge [<-,ultra thick] (s2);
        \draw [<-,dashed,bend right] (s1) to [looseness=1.25] (s3) node[sloped,draw=none] at (2,-0.45) {$/$};

        \node[draw=none] at (0,-1.15)  {};
    \end{tikzpicture}
    %}
    }%
    \qquad
    % \subfloat[Modified prediction with loop removed.]{
    % \begin{tikzpicture}[baseline=(s0.base)]
    %     % states
    %     \node[state] (s0) at (-2,2) {$1$};
    %     \node[state] (s1) at (0,2) {$2$}
    %         edge [<-] (s0);
    %     \node[state] (s2) at (2,2) {$3$}
    %         edge [<-] (s1);
    %     \node[state] (s3) at (4,2) {$4$}
    %         edge [<-] (s2);
    %     \draw [color=white,dashed,bend right] (s1) to [looseness=1.25] (s3);            
    % \end{tikzpicture}
    % }
    %\resizebox{0.2\textwidth}{!}{
    \subfloat[{\sc ILP} (\S\ref{sec:ilp}).]{
    \begin{tikzpicture}[baseline=(s1.base)]
        % first-best
        \node[specialState] (s1) at (0,0)  {$1$};
        \node[specialState] (s2) at (1,1)  {$2$};
        \node[hiddenState]  (s3) at (2,1)  {$3$};
        \node[hiddenState]  (s4) at (1,-1) {$4$};
        \node[specialState] (s5) at (2,-1) {$5$};
        \node[specialState] (s6) at (3,0)  {$6$};

        %\node[draw=none] (juka) at (0,-1.5)  {};

        \draw [->,ultra thick] (s1) to (s2);
        \draw [->,ultra thin] (s1) to (s3);
        \draw [->,ultra thin] (s1) to (s4);
        \draw [->,ultra thin] (s1) to (s5);
        \draw [->,ultra thin] (s1) to (s6);    

        \draw [->,ultra thin] (s2) to (s1);
        \draw [->,ultra thin] (s2) to (s3);
        \draw [->,ultra thin] (s2) to (s4);
        \draw [->,ultra thick] (s2) to (s5);
        \draw [->,ultra thin] (s2) to (s6);    

        \draw [->,ultra thin] (s3) to (s1);
        \draw [->,ultra thin] (s3) to (s2);
        \draw [->,ultra thin] (s3) to (s4);
        \draw [->,ultra thin] (s3) to (s5);
        \draw [->,ultra thin] (s3) to (s6);    

        \draw [->,ultra thin] (s4) to (s2);
        \draw [->,ultra thin] (s4) to (s3);
        \draw [->,ultra thin] (s4) to (s1);
        \draw [->,ultra thin] (s4) to (s5);
        \draw [->,ultra thin] (s4) to (s6);    

        \draw [->,ultra thin] (s5) to (s2);
        \draw [->,ultra thin] (s5) to (s3);
        \draw [->,ultra thin] (s5) to (s4);
        \draw [->,ultra thin] (s5) to (s1);
        \draw [->,ultra thick] (s5) to (s6);    

        \draw [->,ultra thin] (s6) to (s2);
        \draw [->,ultra thin] (s6) to (s3);
        \draw [->,ultra thin] (s6) to (s4);
        \draw [->,ultra thin] (s6) to (s5);
        \draw [->,ultra thin] (s6) to (s1);                    
    \end{tikzpicture}
    %}
    }%
    \qquad
    \subfloat[{\sc List Viterbi} (\S\ref{sec:viterbi}).]{
    \begin{tikzpicture}[baseline=(s1.base)]
        % first-best
        \node[state] (s1) at (0,0)  {$1$};
        \node[state] (s2) at (1,0)  {$2$}            
            edge [<-] (s1);

        \node[specialState] (ss1) at (0,-1) {{${5}$}};                            
        \node[specialState] (ss2) at (1,-1) {{${6}$}}
            edge [<-,ultra thick,decorate,decoration={snake}] (ss1);

        \node[specialState] (s3) at (2,0)  {$3$}            
            edge [<-] (s2)
            edge [<-,ultra thick,decorate,decoration={snake}] (ss2);

        \node[specialState] (s4) at (3,0) {$4$}
            edge [<-,ultra thick] (s3);

        %\draw [<-,dashed,bend left] (s2) to [looseness=1.25] (s4); 
    \end{tikzpicture}
    }
    
    %\caption{Example of heuristically removing loops. The nodes are numbered by the POI, with edges denoting order in the sequence. While the modified prediction removes the loop in the original sequence, it is necessarily at the expense of returning a path with fewer number of POIs.}
    \caption{Schematics of different algorithms to return a loop-free prediction.
    {\sc Greedy} selects POIs one at a time, so as to locally maximise the sub-sequence score while ensuring we do not repeat POIs;
    {\sc LoopElim} removes the loop from the Viterbi solution, possibly returning a path of shorter length than requested;
    {\sc ILP} solves an integer linear program to find the optimal sequence of length $l$ in a complete graph over POIs;
    {\sc ListViterbi} finds the point where the second best sequence merges with the first best (standard Viterbi) sequence.
    }
    \label{fig:schematics}
\end{figure*}


% {\color{red!75}
% \begin{itemize}
% 	%\item connect to workshop
% 	%\item distinguish between next location vs whole trajectory
% 	%\item define word usage: trajectory, path, walk, sequence, tour, etc.
% 	\item describe relation to travelling salesman, and say why different
% 	%\item contributions of this paper
% \end{itemize}
% }
