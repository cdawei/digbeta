% !TEX root=main.tex

We now formalise the problem of interest and outline its challenges.

%
\subsection{Trajectory recommendation}

Fix some set $\PCal$ of points-of-interest (POIs) in a city.
A \emph{trajectory}\footnote{In graph theory, this is also referred to as a walk.} is any sequence of POIs, possibly containing loops (repeated POIs).
In the \emph{trajectory recommendation} problem, we are given as input a training set of historical tourists' trajectories.
From this, we wish to design a \emph{trajectory recommender}, which accepts a
\emph{trajectory query} $\x = (s, l)$, comprising a start POI $s \in \PCal$, and trip length $l \!>\! 1$, %(\ie the desired number of POIs, including $s$),
and produces one or more sequences of $l$ POIs starting from $s$. %that conform to the query.

Formally, let $\XCal \defEq \PCal \times \{ 2, 3, \ldots \}$ be the set of possible queries,
$\YCal \defEq \bigcup_{l = 2}^\infty \PCal^l$ be the set of all possible trajectories,
and for fixed $\x \in \XCal$, $\YCal_{\x} \subset \YCal$ be the set of trajectories that conform to the constraints imposed by $\x$
\ie if $\x = (s, l)$ then $\YCal_{\x} = \PCal^l$.
Then, the {trajectory recommendation} problem has:

\vspace{0.5\baselineskip}

\begin{mdframed}[innertopmargin=3pt,innerbottommargin=3pt,skipbelow=5pt,roundcorner=8pt,backgroundcolor=red!3,topline=false,rightline=false,leftline=false,bottomline=false]
	\begin{tabular}{ll}
		{\sc Input}:  & training set $\left\{ \left( \x^{(i)}, \y^{(i)} \right) \right\}_{i = 1}^n \in ( \XCal \times \YCal )^n$ \\
		{\sc Output}: & a trajectory recommender $r \colon \XCal \to \YCal$ \\
	\end{tabular}
\end{mdframed}

\vspace{0.5\baselineskip}

One way to design a trajectory recommender is to find a (query, trajectory) affinity function $f \colon \XCal \times \YCal \to \mathbb{R}$, and let
\begin{equation}
	\label{eqn:argmax}
	r( x ) \defEq \argmax_{\y \in \YCal_x}~f(\x, \y).
\end{equation}
%In particular, $\y = (s,~ y_2, \dots, y_l)$ is a trajectory with $l$ POIs. %, which has no sub-tours. %i.e. $y_j \ne y_k$ if $j \ne k$.
%This was the view proposed in~\cite{cikm16paper} where they authors considered an
%objective function that added two components together: a POI score and a transition score.
Several choices of $f$ are possible.
\citet{cikm16paper} proposed to use $f$ given by a RankSVM model, combined with a transition score between POIs.
While offering strong performance, this method has a conceptual disadvantage highlighted in the previous section:
it does not model global cohesion, and thus can lead to solutions such as recommending three restaurants in a row.
To overcome this, \citet{Chen:2017} proposed to use $f$ given by a structured SVM (SSVM).
In the case of an SSVM with pairwise potentials, the optimisation in Equation \ref{eqn:argmax} can be solved with the classic Viterbi algorithm.


%
\subsection{Path recommendation}

We argue that the definition of trajectory recommendation is incomplete for a simple reason:
in most cases, a tourist will not want to revisit the same POI.
We argue that what is needed is to recommend a \emph{path}, \ie a trajectory that does not have any repeated POIs.
Let $\thickbar{\YCal} \subset \YCal$ be the set of all possible paths,
and for fixed $\x \in \XCal$, let $\thickbar{\YCal}_{\x} \subset \thickbar{\YCal}$ be the set of paths that conform to the constraints imposed by $\x$.
We now wish to construct a \emph{path recommender} $r \colon \XCal \to \thickbar{\YCal}$ via
\begin{equation}
	\label{eqn:argmax-path}
	r( x ) \defEq \argmax_{\y \in \thickbar{\YCal}_x}~f(\x, \y).
\end{equation}
For $f$ given by an SSVM, Equation \ref{eqn:argmax-path} requires we depart from the standard Viterbi algorithm, as the sequence in Equation \ref{eqn:argmax} may well have a loop.
There are two distinct modes of attack available:
\begin{enumerate}
	\item seek an approximate solution to the problem,
	via heuristics that exploit a graph view of Equation \ref{eqn:argmax-path}.
	%that remove loops present in the standard Viterbi solution,
	%or by greedily constructing a loop-free solution.

	\item seek an exact solution to the problem,
	via integer linear programming,
	or top-$K$ extensions of the Viterbi algorithm. %(known as list Viterbi algorithms).
\end{enumerate}
We now detail these possible approaches in more detail.
Figure \ref{fig:schematics} gives a schematic overview of these algorithms.

\tikzstyle{state}=[shape=circle,draw=blue!50,fill=blue!20]
\tikzstyle{state2}=[shape=circle,draw=purple!50,fill=purple!20]
\tikzstyle{hiddenState}=[shape=circle,draw=gray!50,fill=gray!20,dashed]
\tikzstyle{specialState}=[shape=circle,double=red,draw=blue!50,fill=blue!20,dashed]
\tikzstyle{observation}=[shape=rectangle,draw=orange!50,fill=orange!20]
\tikzstyle{hiddenObservation}=[shape=rectangle,draw=gray!50,fill=gray!20,dashed]
\tikzstyle{lightedge}=[<-,thin]
\tikzstyle{mainstate}=[state,ultra thick]
\tikzstyle{mainedge}=[<-,ultra thick]

\begin{figure*}[!h]
    \centering
    %\resizebox{0.2\textwidth}{!}{
    \subfloat[{\sc LoopElim} (\S\ref{sec:loop-elim}).]{
    \begin{tikzpicture}[baseline=(s0.base)]
        % states
        \node[specialState] (s0) at (0,0) {$1$};
        \node[specialState] (s1) at (1,0) {$2$}
            edge [<-,ultra thick] (s0);
        \node[specialState] (s2) at (2,0) {$3$}
            edge [<-,ultra thick] (s1);
        %\node[state] (s3) at (3,0) {$4$}
        %    edge [<-,ultra thick] (s2);
        
        %\draw [<-,ultra thin,bend right] (s1) to [looseness=1.25] (s3) node[sloped,draw=none] at (2,-0.45) {$/$};
        \draw [<-,ultra thin,bend right] (s0) to [looseness=1.25] (s2) node[sloped,draw=none] at (1,-0.45) {$/$};

        \node[draw=none] at (0,-1.15)  {};
    \end{tikzpicture}
    %}
    }%
    \qquad    
    %\subfloat[Original prediction with loop (dashed).]{
    \subfloat[{\sc Greedy} (\S\ref{sec:greedy}).]{
    \begin{tikzpicture}[baseline=(s12.base)]
        % first-best
        \node[specialState] (s11) at (0,1)  {$1$};
        \node[hiddenState]  (s12) at (0,0)  {$2$};
        \node[hiddenState]  (s13) at (0,-1) {$3$};

        %\node[hiddenState] (s2) at (1,1.5)  {$2$};
        \node[hiddenState]  (s21) at (1,1)  {$1$};
        \node[specialState] (s22) at (1,0)  {$2$};
        \node[hiddenState]  (s23) at (1,-1) {$3$};
        %\node[hiddenState] (s6) at (1,-1.5)  {$6$};

        \node[draw=none] (s32) at (2,1)  {};
        \node[draw=none] (s31) at (2,0)  {};
        \node[draw=none] (s33) at (2,-1) {};

        \node[draw=none] (s411) at (2.25,0)     {$\ldots$};

        %\draw [->,ultra thin] (s1) to (s2);
        \draw [->,ultra thin]      (s11) to (s21) node [draw=none] at (0.5,1) {$/$};
        \draw [->,ultra thick] (s11) to (s22);
        \draw [->,ultra thin]  (s11) to (s23);
        %\draw [->,ultra thin] (s1) to (s6);

        \draw [->,ultra thin] (s22) to (s32) node [draw=none] at (1.5,0.5) {$/$};
        \draw [->,ultra thin] (s22) to (s31) node [draw=none] at (1.5,0)     {$/$};
        \draw [->,ultra thin] (s22) to (s33);
    \end{tikzpicture}
    }%   
    \qquad
    % \subfloat[Modified prediction with loop removed.]{
    % \begin{tikzpicture}[baseline=(s0.base)]
    %     % states
    %     \node[state] (s0) at (-2,2) {$1$};
    %     \node[state] (s1) at (0,2) {$2$}
    %         edge [<-] (s0);
    %     \node[state] (s2) at (2,2) {$3$}
    %         edge [<-] (s1);
    %     \node[state] (s3) at (4,2) {$4$}
    %         edge [<-] (s2);
    %     \draw [color=white,dashed,bend right] (s1) to [looseness=1.25] (s3);            
    % \end{tikzpicture}
    % }
    %\resizebox{0.2\textwidth}{!}{
    \subfloat[{\sc ILP} (\S\ref{sec:ilp}).]{
    \begin{tikzpicture}[baseline=(s1.base)]
        % first-best
        \node[specialState] (s1) at (0,0)  {$1$};
        \node[specialState] (s2) at (1,1)  {$2$};
        \node[hiddenState]  (s3) at (2,1)  {$3$};
        \node[hiddenState]  (s4) at (1,-1) {$4$};
        \node[specialState] (s5) at (2,-1) {$5$};
        \node[specialState] (s6) at (3,0)  {$6$};

        %\node[draw=none] (juka) at (0,-1.5)  {};

        \draw [->,ultra thick] (s1) to (s2);
        \draw [->,ultra thin] (s1) to (s3);
        \draw [->,ultra thin] (s1) to (s4);
        \draw [->,ultra thin] (s1) to (s5);
        \draw [->,ultra thin] (s1) to (s6);    

        \draw [->,ultra thin] (s2) to (s1);
        \draw [->,ultra thin] (s2) to (s3);
        \draw [->,ultra thin] (s2) to (s4);
        \draw [->,ultra thick] (s2) to (s5);
        \draw [->,ultra thin] (s2) to (s6);    

        \draw [->,ultra thin] (s3) to (s1);
        \draw [->,ultra thin] (s3) to (s2);
        \draw [->,ultra thin] (s3) to (s4);
        \draw [->,ultra thin] (s3) to (s5);
        \draw [->,ultra thin] (s3) to (s6);    

        \draw [->,ultra thin] (s4) to (s2);
        \draw [->,ultra thin] (s4) to (s3);
        \draw [->,ultra thin] (s4) to (s1);
        \draw [->,ultra thin] (s4) to (s5);
        \draw [->,ultra thin] (s4) to (s6);    

        \draw [->,ultra thin] (s5) to (s2);
        \draw [->,ultra thin] (s5) to (s3);
        \draw [->,ultra thin] (s5) to (s4);
        \draw [->,ultra thin] (s5) to (s1);
        \draw [->,ultra thick] (s5) to (s6);    

        \draw [->,ultra thin] (s6) to (s2);
        \draw [->,ultra thin] (s6) to (s3);
        \draw [->,ultra thin] (s6) to (s4);
        \draw [->,ultra thin] (s6) to (s5);
        \draw [->,ultra thin] (s6) to (s1);                    
    \end{tikzpicture}
    %}
    }%
    \qquad
    \subfloat[{\sc List Viterbi} (\S\ref{sec:viterbi}).]{
    \begin{tikzpicture}[baseline=(s1.base)]
        % first-best
        \node[specialState] (s1) at (0,0)  {$1$};
        \node[specialState] (s2) at (1,0)  {$2$}            
            edge [<-,ultra thick] (s1);

        \node[specialState] (ss1) at (2,-1) {{${5}$}}
        	edge [<-,ultra thick,decorate,decoration={snake}] (s2);
        \node[specialState] (ss2) at (3,-1) {{${6}$}}
            edge [<-,ultra thick,decorate,decoration={snake}] (ss1);

        \node[hiddenState] (s3) at (2,0)  {$3$}            
            edge [<-,ultra thin] (s2);

        % \node[hiddenState] (s4) at (3,0) {$4$}
        %     edge [<-,ultra thin] (s3);

        %\draw [<-,ultra thin,bend left] (s2) to [looseness=1.25] (s4); 
        \draw [<-,ultra thin,bend left] (s1) to [looseness=1.25] (s3); 
    \end{tikzpicture}
    }
    
    %\caption{Example of heuristically removing loops. The nodes are numbered by the POI, with edges denoting order in the sequence. While the modified prediction removes the loop in the original sequence, it is necessarily at the expense of returning a path with fewer number of POIs.}
    \caption{Schematics of different algorithms to return a loop-free prediction.
    Nodes such as
	{\protect\tikz[baseline=(X.base)]{\protect\node[specialState,inner sep=2pt] (X) {\small$1$}}}
    are selected by the algorithm, with thick edges such as
    {\protect\tikz{\protect\coordinate (X) at (0,0) {}; \protect\coordinate (Y) at (0.5,0) {}; \protect\draw[->,ultra thick] (X) to (Y); \protect\node[draw=none] at (0.25,-0.00625) {}}}
    denoting the sequence ordering.
    {\sc LoopElim} removes the loop from the Viterbi solution (here the POI sequence $(1,2,3,1)$), possibly returning a path of shorter length than requested;    
    {\sc Greedy} incrementally selects POIs which locally maximise the sub-path score, and have not been selected before;
    {\sc ILP} solves an integer linear program to find the optimal length $l$ path in a complete graph over POIs;
    {\sc ListViterbi} finds where the second-best sequence diverges from the standard Viterbi sequence ($(1,2,3,1)$ as before); if not loop-free, it finds where the third-best diverges from the second-best, \emph{etc}.
    }
    \label{fig:schematics}
    \vspace{-0.5\baselineskip}
\end{figure*}


% {\color{red!75}
% \begin{itemize}
% 	%\item connect to workshop
% 	%\item distinguish between next location vs whole trajectory
% 	%\item define word usage: trajectory, path, walk, sequence, tour, etc.
% 	\item describe relation to travelling salesman, and say why different
% 	%\item contributions of this paper
% \end{itemize}
% }
