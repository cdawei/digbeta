\section{Related work}
\label{sec:related}
% related work
% describe each task with related work: the same, the different
% describe that we don't use the order of songs, conflicting findings in literature
% mainly two pieces of work:
% - music recommendation
% - playlist generation
%{\it Some related work.}

\paragraph{Gaussian process}
The AutoDJ system~\cite{platt2002learning} automatically generate playlists given one or more seed songs, 
it learns user preference from song metadata using Gaussian Process Regression,
and generates playlist with songs similar to the seed.


\paragraph{Markov chain approaches}
Playlists are modelled as random walks in a graph where vertices are songs 
and edges represents affinities between a song pairs~\cite{mcfee2011natural}.
This model can be generalised such that edges present groups of songs (by genre, user preference etc.),
which forms a hyper-graph, and a playlist is a random walk in the hyper-graph~\cite{mcfee2012hypergraph}.

The latent Markov embedding algorithm~\cite{chen2012playlist}
learns representations of songs in a latent space in which playlists are modelled as Markov chains,
playlists are then generated by sampling a paths in the latent space from locations specified by user.

\paragraph{Popularity based ranking}
Due to the \emph{long tail} distribution of songs in playlists~\cite{aoscar2010music},
similar to many applications for recommender system, 
a popularity based approach can in fact be comparably competitive~\cite{cremonesi2010performance}.
Popularity has been combined with artist information to provide strong baselines 
for playlist generation~\cite{mcfee2012million,bonnin2013evaluating,bonnin2015automated}.

\paragraph{Review}
A nice survey and review of various approaches for playlist generation~\cite{bonnin2015automated}.


\paragraph{Next song recommendation}
Next song recommendation~\cite{jannach2015beyond} approach that first scoring each song by a number of features
(\eg acoustic features, user preference of artists, social tags, song co-occurrence in playlists etc.),
then fine-tune the ranks of top-scoring songs which hopefully make the recommended next song be a coherent continuation of user's listening history.

Groove radio~\cite{ben2017groove} uses a classification approach to sequentially recommend 
the next song by predicting the probability of each possible song for a specific user, given an artist as seed.
It makes use of various information such as song metadata, usage statistics, acoustic features, popularity of song and artist,
to build features by taking into consideration of user's listening history and the playlist seed (\ie specified artist and user).
Further, this approach can deal with a cold user or artist by falling back higher levels thanks to its hierarchical architecture.


In this paper, we describe two variants of the playlist recommendation problem,
one is augmenting a playlist by recommending a subset of songs from a collection of music $\SCal$,
given the first $K$ seed songs, where $K$ can be any positive integer from 1 to the total number of songs in playlist minus 1.
% in contrast to settings where all songs except the last one are observed\cite{}, or giving a fixed number of seed songs\cite{}.
Another variant is restricting that all songs to recommend are not observed during learning,
\ie in the setting of recommending newly released songs to augment a given playlist, which is an instance of the cold-start problem.
We call the first variant \emph{playlist augmentation} and the second \emph{new song recommendation}.
