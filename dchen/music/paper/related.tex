\section{Related work}
\label{sec:related}
% related work
% describe each task with related work: the same, the different
% describe that we don't use the order of songs, conflicting findings in literature
% mainly two pieces of work:
% - music recommendation
% - playlist generation
%{\it Some related work.}


{\bf Problem type}.
\begin{itemize}
\item playlist generation given seed (\eg a seed song, artist etc.)
\item next song recommendation, given an incomplete playlist with numerous tracks, recommend the next track that the user likely to listen.
\item another closely related task is playlist continuation, given an incomplete playlist with a few tracks, recommend a list of tracks for continuing that playlist.
\end{itemize}


{\bf Method}.
\begin{itemize}
\item Markov chain based approaches + stochastic process based (\ie autodj)
\item closely related to MC approach is finding a path in a graph (\ie kdd'12) or hypergraph (\ie aotm2011)
\item ranking based, especially popularity has been proved to be very informative, further, 
artist info has been combined with popularity in (msd paper) and (cagh paper) proposed to weighting popularity by the collocation of artists, 
achieving even better performance.
\end{itemize}


{\bf Information used}.
\begin{itemize}
\item content data such as acoustic features extracted from the audio waves of songs, lyrics, genre to be shown very informative
\item artist info
\item metadata from the interaction between users and songs, such as popularity, usage stats (groove paper), generally learn latent feature 
by collaborative filtering or family of matrix factorisation techniques.
\item order of tracks in playlist, no consensus in research community, some (a few papers) report the order info is crucial to achieve high quality recommendation,
others (another bunch of papers) found the effects of track order in playlist were negligible.
Mention that we treat playlist as a set of songs in this work, and defer the investigation of track order in playlist as future work.
\end{itemize}


{\bf Problems investigated in this paper}.
\begin{itemize}
\item given a known user (a user whom we have observed a few playlists), recommend a set of songs
\item given a new user (the recsys does not have any information about the user), recommend a set of songs
\item given a set of newly released songs, recommend songs to augment current playlists.
\end{itemize}

{\bf Methods proposed}.
Two ostensibly different but in fact closely related methods,
each one can address all three tasks.
\begin{itemize}
\item classification by focusing at positive examples
\item ranking by focusing at the top
\end{itemize}



The AutoDJ system~\cite{platt2002learning} 
\begin{itemize}
\item Problem: generate playlists given one or more seed songs
\item Method: Gaussian process regression, learn user preference by using songs selected/removed by user are positive/negative examples
\item Info: a large number of albums
\end{itemize}


\cite{mcfee2011natural}
\begin{itemize}
\item Problem: playlist generation
\item Method: Markov chain, Cast playlist generation as a language modelling problem, assume Markov property.
\item Info: acoustic features, tags, artists familiarity.
\end{itemize}


\cite{mcfee2012hypergraph}
\begin{itemize}
\item Problem: playlist generation 
\item Method: Markov chain, random walks in hyper-graph, model playlists as a collection of dialects of languages
\item Info: edge (\ie groups of songs) features:  audio features, learn latent features by factoring users-by-songs matrix 
era of song (release year), artist familiarity, lyrics (applied LDA), social tags from Last.fm, combined a pair of the above features.
\end{itemize}


\cite{chen2012playlist}
\begin{itemize}
\item Problem: playlist generation
\item Method: Markov chains, learns a latent representation of songs from playlists, a song is mapped to a point or a pair of points into a latent space.
a playlist is a path in the latent space (by sampling repeatedly from the transition distribution)
\item Info: playlists only (latent representation of songs are learned)
\end{itemize}


\cite{hariri2012context}
\begin{itemize}
\item Problem: next song recommendation 
\item Method: ranking, topic-based sequential pattern, a song is a set of topics, playlist is a sequence of topicsets, recommend the next song by first matching user's listening history with learned sequential patterns, predict a set of topics for next song, then rank songs using predicted topics as context. (in the context of predicted topics)
\item Info: song title, artist name, frequent tags of songs from last.fm, use song tags to learn a topic-model
\end{itemize}


\cite{bonnin2013evaluating}
\begin{itemize}
\item Problem: next song recommendation 
\item Method: ranking, based on song popularity and artist information
\item Info: popularity of songs, artist information, collocation of artists in playlist, user listening history.
\end{itemize}
This work also argues about order may or may not be useful.


\cite{jannach2015beyond} approach that first scoring each song by a number of features
\begin{itemize}
\item Problem: Next song recommendation
\item Method: ranking, first score songs by numerous features, then take top-scoring songs and re-ranking to minimise the difference between the next track and listening history in terms of one or more playlist characteristics (\eg distribution of tempo, loudness etc.).
\item Info: acoustic features, user preference (\eg artists), social tags, song co-occurrence in playlists etc.
\end{itemize}


Groove radio~\cite{ben2017groove} uses a classification approach to sequentially recommend 
\begin{itemize}
\item Problem: playlist generation, next song recommendation
\item Method: classification 
\item Info: acoustic audio features, latent usage features learned by factorising the user-artist rating matrix, semantic tags, song and artist popularity.
\end{itemize}




\paragraph{Gaussian process}
The AutoDJ system~\cite{platt2002learning} automatically generate playlists given one or more seed songs, 
it learns user preference from song metadata using Gaussian Process Regression,
and generates playlist with songs similar to the seed.


\paragraph{Markov chain approaches}
Playlists are modelled as random walks in a graph where vertices are songs 
and edges represents affinities between a song pairs~\cite{mcfee2011natural}.
This model can be generalised such that edges present groups of songs (by genre, user preference etc.),
which forms a hyper-graph, and a playlist is a random walk in the hyper-graph~\cite{mcfee2012hypergraph}.

The latent Markov embedding algorithm~\cite{chen2012playlist}
learns representations of songs in a latent space in which playlists are modelled as Markov chains,
playlists are then generated by sampling a paths in the latent space from locations specified by user.

\paragraph{Popularity based ranking}
Due to the \emph{long tail} distribution of songs in playlists~\cite{aoscar2010music},
similar to many applications for recommender system, 
a popularity based approach can in fact be comparably competitive~\cite{cremonesi2010performance}.
Popularity has been combined with artist information to provide strong baselines 
for playlist generation~\cite{mcfee2012million,bonnin2013evaluating,bonnin2015automated}.

\paragraph{Review}
A nice survey and review of various approaches for playlist generation~\cite{bonnin2015automated}.


\paragraph{Next song recommendation}
Next song recommendation~\cite{jannach2015beyond} approach that first scoring each song by a number of features
(\eg acoustic features, user preference of artists, social tags, song co-occurrence in playlists etc.),
then fine-tune the ranks of top-scoring songs which hopefully make the recommended next song be a coherent continuation of user's listening history.

Groove radio~\cite{ben2017groove} uses a classification approach to sequentially recommend 
the next song by predicting the probability of each possible song for a specific user, given an artist as seed.
It makes use of various information such as song metadata, usage statistics, acoustic features, popularity of song and artist,
to build features by taking into consideration of user's listening history and the playlist seed (\ie specified artist and user).
Further, this approach can deal with a cold user or artist by falling back higher levels thanks to its hierarchical architecture.


In this paper, we describe two variants of the playlist recommendation problem,
one is augmenting a playlist by recommending a subset of songs from a collection of music $\SCal$,
given the first $K$ seed songs, where $K$ can be any positive integer from 1 to the total number of songs in playlist minus 1.
% in contrast to settings where all songs except the last one are observed\cite{}, or giving a fixed number of seed songs\cite{}.
Another variant is restricting that all songs to recommend are not observed during learning,
\ie in the setting of recommending newly released songs to augment a given playlist, which is an instance of the cold-start problem.
We call the first variant \emph{playlist augmentation} and the second \emph{new song recommendation}.
