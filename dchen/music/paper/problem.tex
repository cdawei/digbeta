\section{Problem statement}
\label{sec:problem}

We formulate the problem of recommending music in three cold-start settings in the context of playlist:
\begin{enumerate}[(a)]
\item Recommending new songs to extend existing playlist;
\item Recommending a set of songs to form a playlist for an existing user;
\item Recommending a set of songs for a new user to form a playlist.
\end{enumerate}

Given a dataset $\DCal$ with $N$ playlists from $U$ users, 
and songs in every playlist are from a music collection with $M$ songs.
Suppose each user has at least one playlist, and each song in the collection 
is appeared in at least one playlist.

Let $P_u$ denote the set of playlists from users $u$,
we aim to learn a function $f(u, i, m)$ that measures the affinity between user $u$, 
playlist $i$ and song $m$. Suppose $f$ has a linear form
\begin{equation}
\label{eq:scorefunc}
f(u, i, m) = {\w_i^u}^\top \x_m,
\end{equation}
where $u \in \{1,\dots,U\}, \ i \in P_u, \, m \in \{1,\dots,M\}$,
vector $\w_i^u$ represents the parameters of playlist $i$ from user $u$,
and $\x_m$ is a feature vector of song $m$.

We address the three code-start settings using one approach, namely, we first score each song 
according to the given information (\eg, an existing playlist, an existing user or a new user),
%then we can form a playlist by either taking the top-K scored songs or sampling songs proportional to their scores.
then take the top scored songs as our recommendation.
Specifically, for the task of recommending newly released songs to extend an existing playlist $i$ from user $u$,
we score each new song $m$ with respect to user $u$ and playlist $i$, as indicated by $\hat f(u, i, m)$.
To recommend a set of songs for an existing user $u$,
since there is no information about the desired playlist, we score each song $m$ with respect to only the user,
as indicated by $\hat f(u, \cdot, m)$.
Finally, we score each song $m$ by $\hat f(\cdot, \cdot, m)$ when recommending a set of songs 
for a new user with no additional information.

It is challenging to learn an affinity function $f$ that can deal the three cold-start settings simultaneously.
In this next section, we propose a multitask objective which provides a function as required here.
